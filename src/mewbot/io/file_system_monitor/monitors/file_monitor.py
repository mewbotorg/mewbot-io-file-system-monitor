# !/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 Mewbot Developers <mewbot@quicksilver.london>
#
# SPDX-License-Identifier: BSD-2-Clause

"""
Stores the file monitor components for the file system monitor.
"""

from __future__ import annotations

from typing import Any, AsyncGenerator, Optional, Set, Tuple

import asyncio
import logging

import aiopath  # type: ignore
import watchfiles
from mewbot.core import InputQueue

from mewbot.io.file_system_monitor.fs_events import (
    FileCreatedAtWatchLocationFSInputEvent,
    FileDeletedFromWatchLocationFSInputEvent,
    FileUpdatedAtWatchLocationFSInputEvent,
    FSInputEvent,
)
from mewbot.io.file_system_monitor.monitors.base_monitor import BaseMonitor, InputState


class BaseFileMonitorMixin(BaseMonitor):
    """
    Provides tools to watch a file for changes to it.
    """

    _logger: logging.Logger

    _input_path_state: InputState = InputState()

    _polling_interval: float = 0.5

    watcher: Optional[AsyncGenerator[Set[Tuple[watchfiles.Change, str]], None]]

    queue: InputQueue | None

    @property
    def input_path(self) -> Optional[str]:
        """
        The path being watched by the file type monitor.

        :return:
        """
        return self._input_path_state.input_path

    @input_path.setter
    def input_path(self, new_input_path: Optional[str]) -> None:
        """
        Set the path to be watched.

        :param new_input_path:
        :return:
        """
        self._input_path_state.input_path = new_input_path

    @property
    def input_path_exists(self) -> bool:
        """
        Checks to see if the input path is registered as exists.

        :return:
        """
        return self._input_path_state.input_path_exists

    @input_path_exists.setter
    def input_path_exists(self, value: Any) -> None:
        """
        Input path is determined internally using some variant of os.path.
        """
        raise AttributeError("input_path_exists cannot be externally set")

    async def send(self, event: FSInputEvent) -> None:
        """
        Put an event generated by one of the monitors on the file.

        :param event:
        :return:
        """
        if self.queue is None:
            return

        await self.queue.put(event)

    async def input_path_file_created_task(
        self, target_async_path: aiopath.AsyncPath
    ) -> None:
        """
        Called when _monitor_file detects that there's now something at the input_path location.

        Spun off into a separate method because want to get into starting the watch as fast as
        possible.
        """
        if self._input_path_state.input_path is None:
            self._logger.error(
                "Unexpected call to _input_path_file_created_task - _input_path is None!"
            )
            return

        if (
            self._input_path_state.input_path is not None
            and self._input_path_state.input_path_type == "dir"
        ):
            self._logger.warning(
                "Unexpected call to _input_path_file_created_task - "
                "_input_path is not None but _input_path_type is dir"
            )

        str_path: str = self._input_path_state.input_path

        if await target_async_path.is_dir():
            self._logger.info(
                'New asset at "%s" detected as dir', self._input_path_state.input_path
            )

        elif await target_async_path.is_file():
            self._logger.info(
                'New asset at "%s" detected as file', self._input_path_state.input_path
            )

            await self.send(
                FileCreatedAtWatchLocationFSInputEvent(path=str_path, base_event=None)
            )

        else:
            self._logger.warning(
                "Unexpected case in _input_path_created_task - %s", target_async_path
            )

    async def monitor_file_watcher(self) -> None:
        """
        Actually do the job of monitoring and responding to the watcher.

        If the file is detected as deleted, then the
        """
        # Ideally this would be done with some kind of run-don't run lock
        # Waiting on better testing before attempting that.
        if self.watcher is None:
            self._logger.info("Unexpected case - self.watcher is None in _monitor_watcher")
            await asyncio.sleep(
                self._polling_interval
            )  # Give the rest of the loop a chance to act
            return

        async for changes in self.watcher:
            file_deleted = await self.process_changes(changes)

            if file_deleted:
                # File is detected as deleted
                # - shutdown the watcher
                # - indicate we need to start monitoring for a new file
                # (or folder - in which case this will do nothing more)
                # - (Putting an event to indicate this on the wire should have happened elsewhere)
                self.watcher = None
                self._input_path_state.input_path_exists = False

                return

    async def process_changes(self, changes: Set[tuple[watchfiles.Change, str]]) -> bool:
        """
        Turn the product of a watchfile watcher into events to put on the wire.

        :param changes:
        :return:
        """
        # Changes are sets of chance objects
        # tuples with
        #  - the first entry being a watchfiles.Change object
        #  - the second element being a str path to the changed item

        for change in changes:
            change_type, change_path = change

            if change_type == watchfiles.Change.added:
                self._logger.warning(
                    "With how we are using watchfiles this point should never be reached "
                    "- %s - '%s'",
                    change_type,
                    change_path,
                )

            elif change_type == watchfiles.Change.modified:
                await self.do_update_event(change_path, change)

            elif change_type == watchfiles.Change.deleted:
                await self.do_delete_event(change_path, change)
                return True

            else:
                self._logger.warning(
                    "Unexpected case when trying to parse file change - %s", change_type
                )

        return False

    async def do_update_event(
        self, change_path: str, raw_change: tuple[watchfiles.Change, str]
    ) -> None:
        """
        Called when the monitored file is updated.
        """
        await self.send(
            FileUpdatedAtWatchLocationFSInputEvent(
                path=change_path,
                base_event=raw_change,
            )
        )

    async def do_delete_event(
        self, change_path: str, raw_change: tuple[watchfiles.Change, str]
    ) -> None:
        """
        Called when the monitored file is deleted.
        """
        await self.send(
            FileDeletedFromWatchLocationFSInputEvent(
                path=change_path,
                base_event=raw_change,
            )
        )
